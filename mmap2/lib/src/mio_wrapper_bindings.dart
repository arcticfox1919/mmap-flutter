// Copyright (c) 2025, mmap2 project.
// All rights reserved.

// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for mio_wrapper library
class MioBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  MioBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  MioBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie = _lookup<ffi.UintPtr>(
    '__security_cookie',
  );

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  /// Create a memory map from a file path
  /// @param path Path to the file to map
  /// @param access_mode Access mode (MIO_ACCESS_READ or MIO_ACCESS_WRITE)
  /// @param offset Offset in bytes from the beginning of the file
  /// @param length Length to map (0 for entire file)
  /// @param error Pointer to store error code
  /// @return Handle to the memory map or NULL on error
  ffi.Pointer<MioMmapHandle> mio_mmap_create_from_path(
    ffi.Pointer<ffi.Char> path,
    MioAccessMode access_mode,
    int offset,
    int length,
    ffi.Pointer<ffi.UnsignedInt> error,
  ) {
    return _mio_mmap_create_from_path(
      path,
      access_mode.value,
      offset,
      length,
      error,
    );
  }

  late final _mio_mmap_create_from_pathPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<MioMmapHandle> Function(
            ffi.Pointer<ffi.Char>,
            ffi.UnsignedInt,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.UnsignedInt>,
          )
        >
      >('mio_mmap_create_from_path');
  late final _mio_mmap_create_from_path = _mio_mmap_create_from_pathPtr
      .asFunction<
        ffi.Pointer<MioMmapHandle> Function(
          ffi.Pointer<ffi.Char>,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
        )
      >();

  /// Create a memory map from a file handle
  /// @param file_handle File handle (int on Unix, HANDLE on Windows)
  /// @param access_mode Access mode (MIO_ACCESS_READ or MIO_ACCESS_WRITE)
  /// @param offset Offset in bytes from the beginning of the file
  /// @param length Length to map (0 for entire file)
  /// @param error Pointer to store error code
  /// @return Handle to the memory map or NULL on error
  ffi.Pointer<MioMmapHandle> mio_mmap_create_from_handle(
    int file_handle,
    MioAccessMode access_mode,
    int offset,
    int length,
    ffi.Pointer<ffi.UnsignedInt> error,
  ) {
    return _mio_mmap_create_from_handle(
      file_handle,
      access_mode.value,
      offset,
      length,
      error,
    );
  }

  late final _mio_mmap_create_from_handlePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<MioMmapHandle> Function(
            ffi.IntPtr,
            ffi.UnsignedInt,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.UnsignedInt>,
          )
        >
      >('mio_mmap_create_from_handle');
  late final _mio_mmap_create_from_handle = _mio_mmap_create_from_handlePtr
      .asFunction<
        ffi.Pointer<MioMmapHandle> Function(
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
        )
      >();

  /// Get the data pointer from the memory map
  /// @param handle Handle to the memory map
  /// @return Pointer to the mapped data or NULL if invalid
  ffi.Pointer<ffi.Uint8> mio_mmap_get_data(ffi.Pointer<MioMmapHandle> handle) {
    return _mio_mmap_get_data(handle);
  }

  late final _mio_mmap_get_dataPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<MioMmapHandle>)
        >
      >('mio_mmap_get_data');
  late final _mio_mmap_get_data = _mio_mmap_get_dataPtr
      .asFunction<
        ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<MioMmapHandle>)
      >();

  /// Get the writable data pointer from the memory map (only for write-enabled maps)
  /// @param handle Handle to the memory map
  /// @return Pointer to the mapped data or NULL if invalid or read-only
  ffi.Pointer<ffi.Uint8> mio_mmap_get_data_writable(
    ffi.Pointer<MioMmapHandle> handle,
  ) {
    return _mio_mmap_get_data_writable(handle);
  }

  late final _mio_mmap_get_data_writablePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<MioMmapHandle>)
        >
      >('mio_mmap_get_data_writable');
  late final _mio_mmap_get_data_writable = _mio_mmap_get_data_writablePtr
      .asFunction<
        ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<MioMmapHandle>)
      >();

  /// Get the size of the mapped region
  /// @param handle Handle to the memory map
  /// @return Size in bytes, 0 if invalid handle
  int mio_mmap_get_size(ffi.Pointer<MioMmapHandle> handle) {
    return _mio_mmap_get_size(handle);
  }

  late final _mio_mmap_get_sizePtr =
      _lookup<
        ffi.NativeFunction<ffi.Size Function(ffi.Pointer<MioMmapHandle>)>
      >('mio_mmap_get_size');
  late final _mio_mmap_get_size = _mio_mmap_get_sizePtr
      .asFunction<int Function(ffi.Pointer<MioMmapHandle>)>();

  /// Get the actual mapped length (may be larger due to page alignment)
  /// @param handle Handle to the memory map
  /// @return Actual mapped length in bytes, 0 if invalid handle
  int mio_mmap_get_mapped_length(ffi.Pointer<MioMmapHandle> handle) {
    return _mio_mmap_get_mapped_length(handle);
  }

  late final _mio_mmap_get_mapped_lengthPtr =
      _lookup<
        ffi.NativeFunction<ffi.Size Function(ffi.Pointer<MioMmapHandle>)>
      >('mio_mmap_get_mapped_length');
  late final _mio_mmap_get_mapped_length = _mio_mmap_get_mapped_lengthPtr
      .asFunction<int Function(ffi.Pointer<MioMmapHandle>)>();

  /// Check if the memory map is open
  /// @param handle Handle to the memory map
  /// @return 1 if open, 0 if not
  int mio_mmap_is_open(ffi.Pointer<MioMmapHandle> handle) {
    return _mio_mmap_is_open(handle);
  }

  late final _mio_mmap_is_openPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MioMmapHandle>)>>(
        'mio_mmap_is_open',
      );
  late final _mio_mmap_is_open = _mio_mmap_is_openPtr
      .asFunction<int Function(ffi.Pointer<MioMmapHandle>)>();

  /// Check if the memory map is mapped
  /// @param handle Handle to the memory map
  /// @return 1 if mapped, 0 if not
  int mio_mmap_is_mapped(ffi.Pointer<MioMmapHandle> handle) {
    return _mio_mmap_is_mapped(handle);
  }

  late final _mio_mmap_is_mappedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MioMmapHandle>)>>(
        'mio_mmap_is_mapped',
      );
  late final _mio_mmap_is_mapped = _mio_mmap_is_mappedPtr
      .asFunction<int Function(ffi.Pointer<MioMmapHandle>)>();

  /// Sync the memory map to disk (for write-enabled maps)
  /// @param handle Handle to the memory map
  /// @return Error code
  MioError mio_mmap_sync(ffi.Pointer<MioMmapHandle> handle) {
    return MioError.fromValue(_mio_mmap_sync(handle));
  }

  late final _mio_mmap_syncPtr =
      _lookup<
        ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<MioMmapHandle>)>
      >('mio_mmap_sync');
  late final _mio_mmap_sync = _mio_mmap_syncPtr
      .asFunction<int Function(ffi.Pointer<MioMmapHandle>)>();

  /// Destroy the memory map and free resources
  /// @param handle Handle to the memory map
  void mio_mmap_destroy(ffi.Pointer<MioMmapHandle> handle) {
    return _mio_mmap_destroy(handle);
  }

  late final _mio_mmap_destroyPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MioMmapHandle>)>
      >('mio_mmap_destroy');
  late final _mio_mmap_destroy = _mio_mmap_destroyPtr
      .asFunction<void Function(ffi.Pointer<MioMmapHandle>)>();

  /// Get error message string
  /// @param error Error code
  /// @return Error message string
  ffi.Pointer<ffi.Char> mio_get_error_message(MioError error) {
    return _mio_get_error_message(error.value);
  }

  late final _mio_get_error_messagePtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>
      >('mio_get_error_message');
  late final _mio_get_error_message = _mio_get_error_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the library version string
  /// @return Version string in format "major.minor.patch"
  ffi.Pointer<ffi.Char> mio_get_version() {
    return _mio_get_version();
  }

  late final _mio_get_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'mio_get_version',
      );
  late final _mio_get_version = _mio_get_versionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();
}

typedef va_list = ffi.Pointer<ffi.Char>;
typedef ptrdiff_t = ffi.LongLong;
typedef Dartptrdiff_t = int;
typedef errno_t = ffi.Int;
typedef Darterrno_t = int;
typedef wint_t = ffi.UnsignedShort;
typedef Dartwint_t = int;
typedef wctype_t = ffi.UnsignedShort;
typedef Dartwctype_t = int;
typedef __time32_t = ffi.Long;
typedef Dart__time32_t = int;
typedef __time64_t = ffi.LongLong;
typedef Dart__time64_t = int;

final class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

final class __crt_locale_data extends ffi.Opaque {}

final class __crt_multibyte_data extends ffi.Opaque {}

final class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;

final class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

typedef mbstate_t = _Mbstatet;
typedef time_t = __time64_t;
typedef rsize_t = ffi.Size;
typedef Dartrsize_t = int;
typedef int_least8_t = ffi.SignedChar;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Short;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.LongLong;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.UnsignedChar;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.UnsignedShort;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.UnsignedInt;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.UnsignedLongLong;
typedef Dartuint_least64_t = int;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.LongLong;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedInt;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedInt;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLongLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.LongLong;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLongLong;
typedef Dartuintmax_t = int;

final class MioMmapHandle extends ffi.Opaque {}

/// Error codes
enum MioError {
  MIO_SUCCESS(0),
  MIO_ERROR_INVALID_ARGUMENT(1),
  MIO_ERROR_FILE_NOT_FOUND(2),
  MIO_ERROR_PERMISSION_DENIED(3),
  MIO_ERROR_OUT_OF_MEMORY(4),
  MIO_ERROR_MAPPING_FAILED(5),
  MIO_ERROR_INVALID_HANDLE(6),
  MIO_ERROR_UNKNOWN(7);

  final int value;
  const MioError(this.value);

  static MioError fromValue(int value) => switch (value) {
    0 => MIO_SUCCESS,
    1 => MIO_ERROR_INVALID_ARGUMENT,
    2 => MIO_ERROR_FILE_NOT_FOUND,
    3 => MIO_ERROR_PERMISSION_DENIED,
    4 => MIO_ERROR_OUT_OF_MEMORY,
    5 => MIO_ERROR_MAPPING_FAILED,
    6 => MIO_ERROR_INVALID_HANDLE,
    7 => MIO_ERROR_UNKNOWN,
    _ => throw ArgumentError('Unknown value for MioError: $value'),
  };
}

/// Access modes
enum MioAccessMode {
  MIO_ACCESS_READ(0),
  MIO_ACCESS_WRITE(1);

  final int value;
  const MioAccessMode(this.value);

  static MioAccessMode fromValue(int value) => switch (value) {
    0 => MIO_ACCESS_READ,
    1 => MIO_ACCESS_WRITE,
    _ => throw ArgumentError('Unknown value for MioAccessMode: $value'),
  };
}

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_CXX26 = 0;

const int _HAS_NODISCARD = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 'C';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;
